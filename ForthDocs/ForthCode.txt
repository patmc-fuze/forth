         1         2         3         4         5         6         7
1234567890123456789012345678901234567890123456789012345678901234567890123456789
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

This file contains info about the code generated by forth including:

o code optimization and combo ops
o the code generated for builds...does words
o the code generated for control structures
  o if...else...endif
  o do...loop
o the code generated for local variables

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Code optimizations and combo ops.

Compilation of combo ops:

Combo ops are a set of optimizations that

A circular peephole buffer is kept of pointers to previous opcodes compiled.

The peephole buffer is cleared whenever looking at previous opcodes would be invalid:
o at the start of compiling an op or method
o after compiling an exit opcode
o after compiling a branch opcode
o after executing ']' to return to compile mode
o ...

---
Uncompilation
  There is already code which removes compiled code for these cases:
o uncompile int literal in 'SIZE arrayOf TYPE NAME' local array declaration
o uncompile int literal in 'SIZE string NAME' local string declaration
o uncompile last varop before a structure access expression in case where varop
  needs to be moved inside the structure access code
---  
The combo op types are:

 NUM VAROP OP      bits 0:10 are signed integer, bits 11:12 are varop-2, bit 13 is builtin/userdef, bits 14-23 are opcode
 NUM VAROP         bits 0:21 are signed integer, bits 22:23 are varop-2
 NUM OP            bits 0:12 are signed integer, bit 13 is builtin/userdef, bits 14:23 are opcode
 VAROP OP          bits 0:1 are varop-2, bit 2 is builtin/userdef, bits 3:23 are opcode
 OP ZBRANCH        bits 0:11 are opcode, bits 12:23 are signed integer branch offset in longs
 OP BRANCH         bits 0:11 are opcode, bits 12:23 are signed integer branch offset in longs
 LOCAL_REF OP      bits 0:11 are local var offset in longs, bits 12:23 are opcode
 MEMBER_REF OP     bits 0:11 are local var offset in longs, bits 12:23 are opcode

CompileOpcode def:
  if opcode type is builtin:
    if opcode is a varop
      if previous opcode type is NUM
      
    else
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

How builds...does is implemented		 before 2005

: con builds , does @ ;
5 con aha
: woof dup aha + ;

memory after executing above 3 lines of forth:

ADDR(con):  OP( builds )
        +1  OP( , )
        +2  OP( _endBuilds )    this op was compiled by "does"
        +3  OP( _con )          this was compiled by "does"
ADDR(_con): OP( _doDoes )       this op was compiled by "does"
        +1  OP( @ )
        +2  OP( exit )

ADDR(aha):  OP( _con )          this op was compiled as op 0 by builds, then set to _con by _endBuilds
        +1  DATA_STORAGE( aha ), contents == 5

ADDR(woof): OP( dup )
        +1  OP( aha )
        +2  OP( + )
        +3  OP( exit )

before executing "woof":
    ps: 7
    rs: <empty>
    ip: OLD_IP_VAL
start of executing woof opcode:
    ps: 7
    rs: OLD_IP_VAL
    ip: ADDR(woof)
start of executing aha opcode:
    ps: 7 7
    rs: ADDR(woof)+2 OLD_IP_VAL
    ip: ADDR(aha)
start of executing _con opcode:
    ps: 7 7
    rs: ADDR(aha)+1 ADDR(woof)+2 OLD_IP_VAL
    ip: ADDR(_con)
after executing doDoes:
    ps: ADDR(aha)+1 7 7
    rs: ADDR(woof)+2 OLD_IP_VAL
    ip: ADDR(_con)+1
after executing @ and exit (leaving _con):
    ps: 5 7 7
    rs: OLD_IP_VAL
    ip: ADDR(woof)+2
after executing + and exit (leaving woof):
    ps: 12 7
    rs: <empty>
    ip: OLD_IP_VAL

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

code generated for if...else...endif

: iffy if 1 else 0 endif %

ADDR(iffy): branchZ +2
        +1  intLit( 1 )
        +2  branch +1
        +3  intLit( 0 )
        +4  OP( . )
        +5  OP( exit )

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

code generated for do ... loop

: looy 5 0 do i . %bl loop ;

ADDR(looy): intLit( 5 )
        +1  intLit( 0 )
        +2  OP( _do )
        +3  branch +4
        +4  OP( i )
        +5  OP( . )
        +6  OP( %bl )
        +7  OP( _loop )
        +8  OP( exit )

TBDs:
- show how leave works
- show how unloop works
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

: fur vars int a float b endvars 5 -> a 2 ->+ a a . ;

ADDR(fur):  allocLocals( 2 )
        +1  intLit( 5 )
        +2  OP( -> )
        +3  localInt( 0 )
        +5  intLit( 2 )
        +6  OP( ->+ )
        +7  localInt( 0 )
        +8  localInt( 0 )
        +9  OP( . )
        +10 OP( exit )

allocLocals pushed a special IP on the stack which points to an _unravelFrame
opcode, which will remove the local variable stack frame and return to the
caller of "fur"

TBDs:
- show how vars...endvars have been made unnecessary






//       11111111112222222222333333333344444444445555555555666666666677777777778
//345678901234567890123456789012345678901234567890123456789012345678901234567890
<############################# Last Line In File ##############################>
